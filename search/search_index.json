{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to R-Type","text":"<p>R-type is a project that aims to reimagine the classic game \"R-type\" in C++ using a custom game engine and implementing networked multiplayer functionality.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udcbb Cross-platform</li> <li>\ud83c\udf10 Multiplayer</li> <li>\ud83e\udde9 Custom Game Engine</li> <li>\ud83d\udce6 Easy to install</li> <li>\ud83d\udcda Modern Documentation</li> </ul>"},{"location":"#guides","title":"Guides","text":""},{"location":"#user-guide","title":"User Guide","text":"<p>If you want ot play the game, you can check the User Guide. You will be able to find the download links to install the game and the rules of the game.</p>"},{"location":"#client-server-guide","title":"Client &amp; Server Guide","text":"<p>If you want understand how the game work or contribute to the project go check the Client and Server documentation.d the game from source. To do this go check the client and server documentation.</p>"},{"location":"user-guide/","title":"User Guide","text":"<p>R-Type is a shoot'em up game where you control a spaceship and fight against aliens. You can play alone or with friends. Here are the guids to install, config and enjoy the game.</p>"},{"location":"user-guide/#how-to-install","title":"How to install","text":""},{"location":"user-guide/#windows","title":"\ud83e\ude9f Windows","text":"<p>As any other softwares you can just download this exe file and play</p> Target Installer 64 Bit R-Type.exe"},{"location":"user-guide/#linux","title":"\ud83d\udc27 Linux","text":""},{"location":"user-guide/#debian","title":"Debian","text":"<p>Download and run the Debian</p> Target Installer 64 Bit R-Type.deb"},{"location":"user-guide/#rpm","title":"Rpm","text":"<p>Download and run the Debian</p> Target Installer 64 Bit R-Type.rpm"},{"location":"user-guide/#build-from-source","title":"Build from source","text":"<p>You can build the game from source. To do this go check the client and server documentation.</p>"},{"location":"user-guide/#how-to-play","title":"How to play","text":""},{"location":"user-guide/#controls","title":"\ud83c\udfae Controls","text":"<p>Here are the default settings you can always change them in the settings menu.</p> Action Key Move Up Arrow Up Move Down Arrow Down Move Left Arrow Left Move Right Arrow Right Shoot Space Change Weapon F Charge attack R"},{"location":"user-guide/#sole-multiplayer","title":"\ud83d\udd79\ufe0f Sole &amp; Multiplayer","text":""},{"location":"user-guide/#solo","title":"Solo","text":"<ul> <li>You can play without no connection needed. Just launch the game in solo mode and enjoy.</li> </ul>"},{"location":"user-guide/#multiplayer","title":"Multiplayer","text":"<ul> <li>Each person must click on the \"Multiplayer\" button, you will be able to see your ID at the bottom right. Then click the \"Start\" button and once everyone is on this stage, one person must start a level. Everyone will have this level launched.</li> </ul>"},{"location":"client/architecture/","title":"Game Architecture","text":"<p>This section explores the architecture of our R-Type game, developed in C++ using an Entity-Component-System (ECS) based game engine and powered by the SFML library. Understanding this architecture is essential for developers and video game enthusiasts looking to dive into our source code.</p>"},{"location":"client/architecture/#project-structure","title":"Project Structure","text":"<p>Our R-Type project is organized around several key components:</p> <ol> <li> <p>Entities: Entities represent the interactive objects in the game, such as spaceships, enemies, projectiles, and other elements.</p> </li> <li> <p>Components: Components store the data and characteristics of entities. For example, a position component, velocity component, weapon component, health component, and so on.</p> </li> <li> <p>Systems: Systems manage the game's logic by acting on entities based on their components. For example, a rendering system uses SFML to display entities on the screen.</p> </li> </ol>"},{"location":"client/architecture/#data-flow","title":"Data Flow","text":"<p>The ECS architecture follows a specific data flow:</p> <ol> <li> <p>Entity Creation: Entities are constructed by adding relevant components. For instance, a spaceship may have position, velocity, and weapon components.</p> </li> <li> <p>System Execution: Systems are triggered to process entities. For example, a rendering system iterates through entities and displays them on the screen using SFML.</p> </li> <li> <p>Component Updates: Entity components are updated by systems during gameplay. For example, a movement system may change the velocity of projectiles.</p> </li> <li> <p>Interactions and Events: Entities can interact with each other through events. For example, a projectile can inflict damage on an enemy.</p> </li> </ol>"},{"location":"client/architecture/#using-sfml","title":"Using SFML","text":"<p>SFML is our library of choice for managing graphical elements, audio, and other multimedia resources. It is integrated into our game engine to create an immersive visual experience.</p>"},{"location":"client/enemies/","title":"Enemies","text":"<p>R-Type is known for its varied and formidable alien enemies. Get to know your adversaries to better face them and progress in the game.</p>"},{"location":"client/enemies/#types-of-enemies","title":"Types of Enemies","text":""},{"location":"client/enemies/#basic-enemies","title":"Basic Enemies","text":"<ol> <li> <p>Combat Drone: These small drones fly in formations and shoot volleys of projectiles. They are vulnerable, but their numbers can be intimidating.</p> </li> <li> <p>Alien Fighter: Fighters are faster and more aggressive. They hunt the player, performing maneuvers to evade shots.</p> </li> </ol>"},{"location":"client/enemies/#heavy-enemies","title":"Heavy Enemies","text":"<ol> <li> <p>Alien Tank: These ground units are heavily armored and resistant. They shoot powerful projectiles and can be a challenge to defeat.</p> </li> <li> <p>Giant Warship: These massive ships are bosses. They have multiple phases and deadly weapons. Study their firing patterns to defeat them.</p> </li> </ol>"},{"location":"client/enemies/#special-enemies","title":"Special Enemies","text":"<ol> <li> <p>Parasitic Aliens: These tentacled creatures can latch onto the player's ship. They must be shaken off or destroyed before they cause damage.</p> </li> <li> <p>Dimensional Portals: These portals continually summon enemies. It's best to destroy them as soon as possible.</p> </li> </ol>"},{"location":"client/enemies/#strategies-for-defeating-enemies","title":"Strategies for Defeating Enemies","text":"<ul> <li> <p>Study Enemies: Learn the firing patterns, movements, and weak points of each enemy type.</p> </li> <li> <p>Priority: Focus on the most dangerous enemies first. Boss-type enemies should be a priority.</p> </li> <li> <p>Use Power-ups: Power-ups can enhance your weapons and make battles easier.</p> </li> <li> <p>Dodge Shots: Evade enemy projectiles using agile maneuvers.</p> </li> <li> <p>Cooperation: In two-player R-Type games, cooperation is crucial to eliminate enemies more quickly.</p> </li> </ul> <p>By understanding the enemies and employing effective strategies, you will be better prepared to tackle the challenges of R-Type. Happy hunting!</p>"},{"location":"client/main/","title":"Main","text":""},{"location":"client/main/#1-window-and-sound-initialization","title":"1. Window and Sound Initialization:","text":"<ul> <li> <p><code>r::InitWindow(1920, 1080, \"Super Mega Rtype\")</code> initializes a game window with a resolution of 1920x1080 pixels and sets its title.</p> </li> <li> <p><code>r::InitAudioDevice()</code> initializes the audio system.</p> </li> <li> <p><code>r::SetMasterVolume(100)</code> sets the main audio volume to 100%.</p> </li> <li> <p><code>r::ToggleFullscreen()</code> toggles fullscreen mode.</p> </li> <li> <p><code>r::DisableCursor()</code> disables the mouse cursor within the window.</p> </li> </ul>"},{"location":"client/main/#2-creation-of-rendering-sound-and-network-objects","title":"2. Creation of Rendering, Sound, and Network Objects:","text":"<ul> <li> <p><code>Client::Renderer</code> renderer is responsible for the game's graphical rendering.</p> </li> <li> <p><code>Client::SoundRenderer</code> soundRenderer is used for managing sound effects.</p> </li> <li> <p><code>Client::TextRenderer</code> textRenderer handles text display on the screen.</p> </li> <li> <p><code>Client::Networker networker</code> is used for network communication.</p> </li> </ul>"},{"location":"client/main/#3-rngine-game-engine-initialization","title":"3. RNGine Game Engine Initialization:","text":"<ul> <li> <p><code>RNGine::Core</code> core initializes the main game engine.</p> </li> <li> <p>Different game scenes are created, such as \"Home,\" \"Game,\" \"Level1,\" \"Level2,\" etc., each associated with a specific scene class instance.</p> </li> </ul>"},{"location":"client/main/#4-adding-scenes-and-systems","title":"4. Adding Scenes and Systems:","text":"<ul> <li> <p><code>core.AddScene(...)</code> adds the created scenes to the game engine.</p> </li> <li> <p><code>core.AddSystem(...)</code> adds systems to the game engine to manage specific features.</p> </li> </ul>"},{"location":"client/main/#5-main-game-loop","title":"5. Main Game Loop:","text":"<ul> <li> <p>A <code>while</code> loop checks if the window should be closed. As long as the window is not closed, the loop continues to run.</p> </li> <li> <p>Within the loop, <code>core.Update()</code> is called to update the entity states and execute systems.</p> </li> <li> <p>Next, the loop renders the current scene by calling <code>renderer.RenderSprites()</code>, updates sounds with <code>soundRenderer.UpdateSounds()</code>, displays text with <code>textRenderer.UpdateTexts()</code>, and manages mouse position with <code>Client::SetMousePosition()</code>.</p> </li> <li> <p>Finally, the loop updates network communication with <code>networker.Update()</code>.</p> </li> </ul>"},{"location":"client/main/#6-closing-the-game","title":"6. Closing the Game:","text":"<ul> <li> <p>After exiting the main loop, the code closes the audio device with <code>r::CloseAudioDevice()</code>.</p> </li> <li> <p>Then, the game window is closed with <code>r::CloseWindow()</code>.</p> </li> </ul>"},{"location":"client/main/#7-return-value","title":"7. Return Value:","text":"<p>The <code>main</code> function returns 0 to indicate a normal program exit.</p>"},{"location":"client/netWorker/","title":"Networker","text":"<p>The \"Networker\" module is responsible for managing network communications within the game. It enables the sending and receiving of network packets to synchronize information between the client and the server.</p> <p>This module is essential for allowing the game to interact with a remote server, send data, and receive responses, particularly for player authentication.</p>"},{"location":"client/netWorker/#features","title":"Features","text":"<p>The \"Networker\" module performs the following actions:</p> <ul> <li> <p>Initializes the connection with the server by resolving the address and port.</p> </li> <li> <p>Updates network communication by sending and receiving packets.</p> </li> <li> <p>Awaits an authentication response from the server when the current scene is \"lobby.\"</p> </li> </ul>"},{"location":"client/netWorker/#example-usage","title":"Example Usage","text":"<p>The \"Networker\" module is used to handle network communications within the game:</p> <pre><code>// Create an instance of Networker\nClient::Networker networker;\n\n// Inside the game's main loop\nwhile (!r::WindowShouldClose()) {\n    // ...\n    networker.Update(core); // Update network communication\n    // ...\n}\n</code></pre>"},{"location":"client/player/","title":"Player","text":"<p>In the game R-Type, you play as a pilot of a powerful spaceship. Your mission is to navigate through dangerous levels and defeat waves of alien enemies. Here's an overview of how to play as a player in R-Type:</p>"},{"location":"client/player/#basic-controls","title":"Basic Controls","text":"<ul> <li> <p>Movement: Use the arrow keys (or WASD keys) to move your spaceship up, down, left, and right.</p> </li> <li> <p>Primary Shooting: Press the shoot key (usually the spacebar or a controller button) to fire projectiles at enemies.</p> </li> <li> <p>Special Attack: Your spaceship may have a special attack or a super shot. Use the dedicated key to unleash this attack.</p> </li> </ul>"},{"location":"client/player/#gameplay-strategies","title":"Gameplay Strategies","text":"<ul> <li> <p>Avoid Enemy Shots: Enemies will shoot deadly projectiles. Use your piloting skills to dodge these shots.</p> </li> <li> <p>Collect Power-ups: Some enemies will drop power-ups. Collect them to enhance your spaceship, increase your firepower, or gain new abilities.</p> </li> <li> <p>Manage Your Health Bar: Your spaceship has a health bar. Avoid taking too much damage because when the health bar is empty, you'll lose a life.</p> </li> <li> <p>Boss Battles: At the end of each level, you'll face a boss. Learn their attack patterns to defeat them.</p> </li> </ul>"},{"location":"client/player/#tips","title":"Tips","text":"<ul> <li> <p>Be Patient: R-Type is a precision game. Take your time to navigate through levels and plan your attacks.</p> </li> <li> <p>Learn the Levels: Each level has its own challenges and enemies. Learn the levels to anticipate dangers.</p> </li> <li> <p>Cooperation: In some R-Type games, two-player cooperation is possible. Playing as a team can make progress easier.</p> </li> </ul> <p>Enjoy the intense action of R-Type and use these tips to enhance your player skills. Good luck in your space adventure!</p>"},{"location":"client/renderer/","title":"Renderer","text":"<p>The \"Renderer\" module is responsible for rendering sprites in the game. It's responsible for displaying the game's graphical elements, such as characters, enemies, backgrounds, and other visual objects. This module uses the Raylib library to perform texture rendering.</p> <p>Rendering is essential for players to visually experience and interact with the game.</p>"},{"location":"client/renderer/#features","title":"Features","text":"<p>The \"Renderer\" module performs the following actions:</p> <ul> <li> <p>Renders sprites in the current scene using the \"RenderTexture\" components associated with entities.</p> </li> <li> <p>Updates sprites based on their position, transformation, and hitbox.</p> </li> <li> <p>Manages the textures used for rendering.</p> </li> </ul>"},{"location":"client/renderer/#example-usage","title":"Example Usage","text":"<p>The \"Renderer\" module is used to display sprites in the game:</p> <pre><code>// Create an instance of Renderer\nClient::Renderer renderer;\n\n// Inside the game's main loop\nwhile (!r::WindowShouldClose()) {\n    // ...\n    renderer.RenderSprites(core.GetActualScene()); // Display sprites of the current scene\n    // ...\n}\n</code></pre>"},{"location":"client/setMousePosition/","title":"SetMousePosition","text":"<p>The \"SetMousePosition\" module is responsible for updating the mouse position in the game engine. It allows real-time tracking and updating of the mouse coordinates and checking if the left and right mouse buttons are pressed.</p> <p>This module is essential for managing user-mouse interactions, especially for detecting mouse clicks and tracking the mouse's position.</p>"},{"location":"client/setMousePosition/#features","title":"Features","text":"<p>The \"SetMousePosition\" module performs the following actions:</p> <ul> <li> <p><code>r::GetMousePosition()</code>: Retrieves the current mouse coordinates.</p> </li> <li> <p><code>r::IsMouseButtonPressed(r::MOUSE_LEFT_BUTTON)</code>, <code>r::IsMouseButtonPressed(r::MOUSE_RIGHT_BUTTON)</code>: Checks if the left and right mouse buttons are pressed.</p> </li> <li> <p>Updates the mouse position components associated with the game scene with the current mouse information.</p> </li> </ul>"},{"location":"client/setMousePosition/#example-usage","title":"Example Usage","text":"<p>The \"SetMousePosition\" module is used to update the mouse's position in the game. Here's how you can use it in the game's main loop:</p> <pre><code>// Example of usage in the main game loop\nwhile (!r::WindowShouldClose()) {\n    // ...\n    SetMousePosition(scene); // Update the mouse position\n    // ...\n}\n</code></pre>"},{"location":"client/soundRenderer/","title":"SoundRenderer","text":"<p>The \"SoundRenderer\" module is responsible for managing sound effects and music in the game. It allows loading, playing, pausing, and stopping audio files based on in-game events, creating an immersive auditory experience for the player.</p> <p>Sound rendering is essential for adding a sensory dimension to the game by providing audio feedback in response to player actions and in-game events.</p>"},{"location":"client/soundRenderer/#features","title":"Features","text":"<p>The \"SoundRenderer\" module performs the following actions:</p> <ul> <li> <p>Loads audio files from specified paths.</p> </li> <li> <p>Plays sound effects or music based on signals received from the game scene.</p> </li> <li> <p>Manages the sound volume of audio files based on specified parameters.</p> </li> <li> <p>Pauses, resumes, and stops audio file playback as needed.</p> </li> </ul>"},{"location":"client/soundRenderer/#example-usage","title":"Example Usage","text":"<p>The \"SoundRenderer\" module is used to manage sound effects and music in the game:</p> <pre><code>// Creating an instance of SoundRenderer\nClient::SoundRenderer soundRenderer;\n\n// In the main game loop\nwhile (!r::WindowShouldClose()) {\n    // ...\n    soundRenderer.UpdateSounds(core.GetActualScene()); // Manages sound effects and music\n    // ...\n}\n</code></pre>"},{"location":"client/textRenderer/","title":"TextRenderer","text":"<p>The \"TextRenderer\" module is responsible for displaying text on the screen in the game. It allows updating and displaying various text elements, such as scores, levels, character or object lives, etc. This contributes to the game's user interface by providing essential information to players.</p> <p>Text display is important for conveying information to players and for creating an informative and intuitive user interface.</p>"},{"location":"client/textRenderer/#features","title":"Features","text":"<p>The \"TextRenderer\" module performs the following actions:</p> <ul> <li> <p>Displays the player's score.</p> </li> <li> <p>Displays the lives of characters or objects.</p> </li> <li> <p>Displays the current level.</p> </li> <li> <p>Manages the update and display of various text elements.</p> </li> </ul>"},{"location":"client/textRenderer/#example-usage","title":"Example Usage","text":"<p>The \"TextRenderer\" module is used to display text in the game:</p> <pre><code>// Creating an instance of TextRenderer\nClient::TextRenderer textRenderer;\n\n// In the main game loop\nwhile (!r::WindowShouldClose()) {\n    // ...\n    textRenderer.UpdateTexts(core.GetActualScene()); // Updates and displays text\n    // ...\n}\n</code></pre>"},{"location":"client/addons/CollisionWaveSpawn/","title":"CollisionWaveSpawn","text":"<p>The \"CollisionWaveSpawn\" addon is used to manage the generation of collision waves in the game. It is used to dynamically create various types of collisions at regular intervals. It stores the following information:</p> <ul> <li> <p><code>startSpawn</code>: The moment when the generation of the collision wave should begin (expressed in time).</p> </li> <li> <p><code>durationWave</code>: The total duration of the collision wave (expressed in time).</p> </li> <li> <p><code>frequency</code>: The rate at which collisions are generated (expressed in time).</p> </li> <li> <p><code>collisionsType</code>: A list of possible collision types with additional information.</p> </li> </ul> <p>The associated system, \"CollisionWaveSpawnSystem,\" handles the generation of collision waves based on these parameters.</p>"},{"location":"client/addons/CollisionWaveSpawn/#example-usage","title":"Example Usage","text":"<p>The \"CollisionWaveSpawn\" component is used to generate dynamic collision waves in the game by defining the start time, duration, and frequency of the wave. The possible collision types are also defined in the \"collisionsType\" list.</p> <pre><code>// Creating a CollisionWaveSpawn component\nClient::Components::CollisionWaveSpawn collisionWaveSpawn;\ncollisionWaveSpawn.startSpawn = 0; // The wave generation begins at the start of the game\ncollisionWaveSpawn.durationWave = 10.0; // The collision wave lasts for 10 seconds\ncollisionWaveSpawn.frequency = 1.0; // Collisions are generated every 1 second\n\n// Defining possible collision types\ncollisionWaveSpawn.collisionsType.push_back({\n    /* Information about collision 1 */\n}, {\n    /* Information about collision 2 */\n});\n\n// Using the CollisionWaveSpawn component to generate collision waves\n</code></pre>"},{"location":"client/addons/EnemyInfiniteSpawn/","title":"EnemyInfiniteSpawn","text":"<p>The \"EnemySpawn\" addon is used to manage the generation of enemies in the game. It is used to dynamically create enemies at regular intervals. It stores the following information:</p> <ul> <li> <p><code>frequency</code>: The rate at which enemies are generated (expressed in time).</p> </li> <li> <p><code>enemiesType</code>: A list of possible enemy types with additional information.</p> </li> <li> <p><code>lastUpdate</code>: The time of the last update for enemy generation (expressed in time).</p> </li> </ul> <p>The associated system, \"EnemySpawnSystem,\" handles the generation of enemies based on these parameters.</p>"},{"location":"client/addons/EnemyInfiniteSpawn/#example-usage","title":"Example Usage","text":"<p>The \"EnemySpawn\" component is used to dynamically generate enemies in the game by defining the generation frequency and possible enemy types.</p> <pre><code>// Creating an EnemySpawn component\nClient::Components::EnemySpawn enemySpawn;\nenemySpawn.frequency = 2.0; // Enemies are generated every 2 seconds\n\n// Defining possible enemy types\nenemySpawn.enemiesType.push_back({\n    /* Information about enemy 1 */\n}, {\n    /* Information about enemy 2 */\n});\n\n// Using the EnemySpawn component to generate enemies\n</code></pre>"},{"location":"client/addons/EnemyWaveSpawn/","title":"EnemyWaveSpawn","text":"<p>The \"EnemyWaveSpawn\" addon is used to manage the generation of enemies in the form of waves in the game. It allows for the dynamic creation of enemy waves at regular intervals. It stores the following information:</p> <ul> <li> <p><code>startSpawn</code>: The moment when the generation of enemy waves should begin (expressed in time).</p> </li> <li> <p><code>durationWave</code>: The total duration of the enemy wave (expressed in time).</p> </li> <li> <p><code>frequency</code>: The rate at which enemy waves are generated (expressed in time).</p> </li> <li> <p><code>enemiesType</code>: A list of possible enemy types with additional information.</p> </li> <li> <p><code>lastUpdate</code>: The time of the last update for the generation of enemy waves (expressed in time).</p> </li> <li> <p><code>actualDuration</code>: The current duration of the ongoing wave.</p> </li> <li> <p><code>started</code>: An indicator to know if the generation of enemy waves has started.</p> </li> </ul> <p>The associated system, \"EnemyWaveSpawnSystem,\" manages the generation of enemy waves based on these parameters.</p>"},{"location":"client/addons/EnemyWaveSpawn/#example-usage","title":"Example Usage","text":"<p>The \"EnemyWaveSpawn\" component is used to dynamically generate waves of enemy waves in the game by defining the start time, duration, generation frequency, and possible enemy types.</p> <pre><code>// Creating an EnemyWaveSpawn component\nClient::Components::EnemyWaveSpawn enemyWaveSpawn;\nenemyWaveSpawn.startSpawn = 0; // The generation of the enemy wave begins at the start of the game\nenemyWaveSpawn.durationWave = 30.0; // The enemy wave lasts for 30 seconds\nenemyWaveSpawn.frequency = 5.0; // Enemy waves are generated every 5 seconds\n\n// Defining possible enemy types\nenemyWaveSpawn.enemiesType.push_back({\n    /* Information about enemy 1 */\n}, {\n    /* Information about enemy 2 */\n});\n\n// Using the EnemyWaveSpawn component to generate waves of enemy waves\n</code></pre>"},{"location":"client/addons/IsClicked/","title":"IsClicked","text":"<p>The \"IsClicked\" addon is used to record whether an entity has been clicked with the left or right mouse button. It stores the following information:</p> <ul> <li> <p><code>IsClickedRight</code>: A boolean indicating whether the entity has been clicked with the right mouse button.</p> </li> <li> <p><code>IsClickedLeft</code>: A boolean indicating whether the entity has been clicked with the left mouse button.</p> </li> </ul> <p>This component is used to handle mouse click interactions with game entities. The associated \"IsClickedSystem\" updates these values based on information from the \"IsHover\" system and the \"MousePosition\" system.</p>"},{"location":"client/addons/IsClicked/#example-usage","title":"Example Usage","text":"<p>The \"IsClicked\" component is updated by the \"IsClickedSystem,\" which checks whether an entity is currently hovering (\"IsHover\") and the position of the mouse cursor (\"MousePosition\"). If the entity is being hovered over and a mouse click is detected, the \"IsClicked\" component is updated accordingly.</p> <pre><code>// Creating an IsClicked component\nClient::Components::IsClicked isClicked;\n\n// Using the IsClicked component to check if the entity has been clicked\nif (isClicked.IsClickedLeft) {\n    // Perform an action for a left click\n}\n\nif (isClicked.IsClickedRight) {\n    // Perform an action for a right click\n}\n</code></pre>"},{"location":"client/addons/IsHover/","title":"IsHover","text":"<p>The \"IsHover\" addon is used to record whether an entity is currently being hovered over by the mouse cursor. It stores the following value:</p> <ul> <li><code>isHover</code>: A boolean indicating whether the entity is currently being hovered over by the mouse cursor.</li> </ul> <p>This component is used to handle mouse hover interactions with game entities. The associated \"IsHoverSystem\" checks if the mouse cursor is inside the collision area of the entity using the \"Hitbox\" and \"Transform\" components. It updates the \"isHover\" value accordingly.</p>"},{"location":"client/addons/IsHover/#example-usage","title":"Example Usage","text":"<p>The \"IsHover\" component is updated by the \"IsHoverSystem\" to reflect whether an entity is currently being hovered over by the mouse cursor.</p> <pre><code>// Creating an IsHover component\nClient::Components::IsHover isHover;\n\n// Using the IsHover component to check if the entity is being hovered over\nif (isHover.isHover) {\n    // Perform an action when the entity is being hovered over\n}\n</code></pre>"},{"location":"client/addons/OnHoverSprite/","title":"OnHoverSprite","text":"<p>The \"OnHoverSprite\" addon is used to manage the change of an entity's image or sprite when it is hovered over by the mouse cursor. It stores the following information:</p> <ul> <li> <p><code>hoverSprite</code>: The image or sprite that will be displayed when the entity is hovered over.</p> </li> <li> <p><code>isChanged</code>: A boolean indicating whether the displayed image has been changed due to hovering.</p> </li> <li> <p><code>hitbox</code>: A collision area associated with the entity (defined by a 4D vector).</p> </li> <li> <p><code>tmpSprite</code>: The original image or sprite before hovering.</p> </li> </ul> <p>This component allows for the visual appearance of an entity to be modified when it is hovered over by the mouse cursor. The associated \"OnHoverSpriteSystem\" manages the image change based on entity hovering.</p>"},{"location":"client/addons/OnHoverSprite/#example-usage","title":"Example Usage","text":"<p>The \"OnHoverSprite\" component is updated by the \"OnHoverSpriteSystem\" to handle image or sprite changes when the entity is hovered over.</p> <pre><code>// Creating an OnHoverSprite component\nClient::Components::OnHoverSprite onHoverSprite;\n\n// Using the OnHoverSprite component to manage image changes when hovered\nif (onHoverSprite.isChanged) {\n    // Display the image or sprite associated with hovering\n} else {\n    // Display the original image or sprite\n}\n</code></pre>"},{"location":"client/addons/Parallax/","title":"Parallax","text":"<p>The \"Parallax\" addon is used to manage parallax effects in the game. Parallax is a graphic animation technique that creates an illusion of depth by scrolling different background layers at different speeds. This component stores the following information:</p> <ul> <li><code>position</code>: A pair of values (x, y) representing the position of the parallax effect.</li> </ul> <p>The associated \"ParallaxSystem\" manages the update of the parallax effect's position based on the game's progression, creating a visual background scrolling effect.</p>"},{"location":"client/addons/Parallax/#example-usage","title":"Example Usage","text":"<p>The \"Parallax\" component is used to create parallax effects in the game:</p> <pre><code>// Creating a Parallax component\nClient::Components::Parallax parallax;\nparallax.position = {0, 0}; // Initial position of the parallax effect\n\n// Using the Parallax component to manage the parallax effect\n</code></pre>"},{"location":"client/addons/ShipAnimation/","title":"ShipAnimation","text":"<p>The \"ShipAnimation\" addon is used to manage the animation of movements for a spaceship in the game. It allows for controlling animations based on the spaceship's actions, such as moving up, moving down, or stopping (none). This component stores the following information:</p> <ul> <li><code>lastAction</code>: The last action performed by the spaceship, which can have values of None, Up, or Down to represent movements.</li> </ul> <p>The associated \"ShipAnimationSystem\" manages the spaceship's animations based on these actions by modifying the spaceship's sprite animations.</p>"},{"location":"client/addons/ShipAnimation/#example-usage","title":"Example Usage","text":"<p>The \"ShipAnimation\" component is used to control the animations of the spaceship based on its movements:</p> <pre><code>// Creating a ShipAnimation component\nClient::Addons::ShipAnimation shipAnimation;\nshipAnimation.lastAction = Client::Addons::ShipAnimation::None; // The spaceship is not moving initially\n\n// Using the ShipAnimation component to control animations for the spaceship\n</code></pre>"},{"location":"client/addons/SpriteAnimation/","title":"SpriteAnimation","text":"<p>The \"SpriteAnimation\" addon is used to manage sprite animations in the game. It allows for creating animations by scrolling through images in a texture at regular intervals. This component stores the following information:</p> <ul> <li><code>reverse</code>: A boolean indicating if the animation should be reversed (true) or not (false).</li> </ul> <p>-<code>loop</code>: A boolean indicating if the animation should repeat in a loop (true) or stop after a single iteration (false).</p> <p>-<code>multiple</code>: A boolean indicating if the animation has multiple image sequences (true) or a single sequence (false).</p> <p>-<code>finish</code>: A boolean indicating if the animation has reached its end (true) or is in progress (false).</p> <p>-<code>start</code>: A pair of integers (x, y) representing the first image of the animation.</p> <p>-<code>end</code>: A pair of integers (x, y) representing the last image of the animation.</p> <p>-<code>lastFrame</code>: A pair of integers (x, y) representing the last displayed image.</p> <p>-<code>frequency</code>: The time in milliseconds between each image change in the animation.</p> <p>-<code>lastUpdate</code>: The time in milliseconds since the last animation update.</p> <p>The associated \"SpriteAnimationSystem\" manages the updating of sprite animations based on time and the parameters defined in this component.</p>"},{"location":"client/addons/SpriteAnimation/#example-usage","title":"Example Usage","text":"<p>The \"SpriteAnimation\" component is used to create sprite animations in the game:</p> <pre><code>// Creating a SpriteAnimation component\nClient::Components::SpriteAnimation animation;\nanimation.reverse = false; // The animation is not reversed\nanimation.loop = true; // The animation repeats in a loop\nanimation.multiple = true; // The animation has multiple image sequences\nanimation.finish = false; // The animation is in progress\nanimation.start = std::make_pair(0, 0); // First image of the animation\nanimation.end = std::make_pair(3, 3); // Last image of the animation\nanimation.lastFrame = std::make_pair(0, 0); // Last displayed image\nanimation.frequency = 100; // Image change every 100 milliseconds\nanimation.lastUpdate = 0; // Time elapsed since the last update\n\n// Using the SpriteAnimation component to manage a sprite animation\n</code></pre>"},{"location":"client/components/IsClicked/","title":"IsClicked","text":"<p>Le composant \"IsClicked\" est utilis\u00e9 pour enregistrer si une entit\u00e9 a \u00e9t\u00e9 cliqu\u00e9e avec le bouton gauche ou droit de la souris. Il stocke les informations suivantes :</p> <ul> <li> <p><code>IsClickedRight</code>: Un bool\u00e9en indiquant si l'entit\u00e9 a \u00e9t\u00e9 cliqu\u00e9e avec le bouton droit de la souris.</p> </li> <li> <p><code>IsClickedLeft</code>: Un bool\u00e9en indiquant si l'entit\u00e9 a \u00e9t\u00e9 cliqu\u00e9e avec le bouton gauche de la souris. </p> </li> </ul> <p>Ce composant est utilis\u00e9 pour g\u00e9rer les interactions de clic de souris avec les entit\u00e9s du jeu. Le syst\u00e8me associ\u00e9 \"IsClickedSystem\" met \u00e0 jour ces valeurs en fonction des informations provenant du syst\u00e8me \"IsHover\" et du syst\u00e8me \"MousePosition\".</p>"},{"location":"client/components/IsClicked/#exemple-dutilisation","title":"Exemple d'utilisation","text":"<p>Le composant \"IsClicked\" est mis \u00e0 jour par le syst\u00e8me \"IsClickedSystem\", qui v\u00e9rifie si une entit\u00e9 est en cours de survol (\"IsHover\") et la position du curseur de la souris (\"MousePosition\"). Si l'entit\u00e9 est en cours de survol et qu'un clic de souris est d\u00e9tect\u00e9, le composant \"IsClicked\" est mis \u00e0 jour en cons\u00e9quence.</p> <pre><code>// Cr\u00e9ation d'un composant IsClicked\nClient::Components::IsClicked isClicked;\n\n// Utilisation du composant IsClicked pour v\u00e9rifier si l'entit\u00e9 a \u00e9t\u00e9 cliqu\u00e9e\nif (isClicked.IsClickedLeft) {\n    // R\u00e9aliser une action pour un clic gauche\n}\n\nif (isClicked.IsClickedRight) {\n    // R\u00e9aliser une action pour un clic droit\n}\n</code></pre>"},{"location":"client/components/IsHover/","title":"IsHover","text":"<p>Le composant \"IsHover\" est utilis\u00e9 pour enregistrer si une entit\u00e9 est en cours de survol par le curseur de la souris. Il stocke la valeur suivante :</p> <ul> <li><code>isHover</code>: Un bool\u00e9en indiquant si l'entit\u00e9 est actuellement survol\u00e9e par le curseur de la souris.</li> </ul> <p>Ce composant est utilis\u00e9 pour g\u00e9rer les interactions de survol de la souris avec les entit\u00e9s du jeu. Le syst\u00e8me associ\u00e9 \"IsHoverSystem\" v\u00e9rifie si le curseur de la souris se trouve \u00e0 l'int\u00e9rieur de la zone de collision de l'entit\u00e9, en utilisant les composants \"Hitbox\" et \"Transform\". Il met \u00e0 jour la valeur \"isHover\" en cons\u00e9quence.</p>"},{"location":"client/components/IsHover/#exemple-dutilisation","title":"Exemple d'utilisation","text":"<p>Le composant \"IsHover\" est mis \u00e0 jour par le syst\u00e8me \"IsHoverSystem\" pour refl\u00e9ter si une entit\u00e9 est actuellement survol\u00e9e par le curseur de la souris.</p> <pre><code>Copy code\n// Cr\u00e9ation d'un composant IsHover\nClient::Components::IsHover isHover;\n\n// Utilisation du composant IsHover pour v\u00e9rifier si l'entit\u00e9 est en cours de survol\nif (isHover.isHover) {\n// R\u00e9aliser une action lorsque l'entit\u00e9 est survol\u00e9e\n}\n</code></pre>"},{"location":"client/components/MousePosition/","title":"Component \"MousePosition\"","text":"<p>The \"MousePosition\" component is used to store information related to the mouse's position in the game. It allows tracking the mouse's position as well as the state of the left and right mouse buttons. This component stores the following information:</p> <ul> <li> <p><code>position</code>: An object of type r::Vector2 representing the current mouse position in the game (x and y coordinates).</p> </li> <li> <p><code>right_click</code>: A boolean indicating if the right mouse button is pressed (true) or not (false).</p> </li> <li> <p><code>left_click</code>: A boolean indicating if the left mouse button is pressed (true) or not (false).</p> </li> </ul> <p>This component is essential for interacting with game elements that depend on the mouse's position and actions, such as buttons, menus, or interactive elements.</p>"},{"location":"client/components/MousePosition/#example-usage","title":"Example Usage","text":"<p>The \"MousePosition\" component is used to track the mouse's position and the state of the mouse buttons in the game:</p> <pre><code>// Creating a MousePosition component\nClient::Components::MousePosition mousePosition;\nmousePosition.position.x = 100; // Mouse's x position\nmousePosition.position.y = 200; // Mouse's y position\nmousePosition.right_click = false; // Right mouse button not pressed\nmousePosition.left_click = true; // Left mouse button pressed\n\n// Using the MousePosition component to manage mouse interaction\n</code></pre>"},{"location":"client/components/NumberLevels/","title":"NumberLevel Component","text":"<p>The \"NumberLevel\" component is used to store the level number in the game. It allows tracking the current level number that the player is currently playing. This component stores the following information:</p> <ul> <li><code>numberLevel</code>: An integer representing the current level number in the game.</li> </ul> <p>This component is useful for tracking and displaying the current level number that the player is playing, which can be helpful in the user interface or for managing game progression.</p>"},{"location":"client/components/NumberLevels/#example-usage","title":"Example Usage","text":"<p>The \"NumberLevel\" component is used to track and display the current level number:</p> <pre><code>// Creating a NumberLevel component\nClient::Components::NumberLevel level;\nlevel.numberLevel = 1; // The player is currently playing level 1\n\n// Using the NumberLevel component to display the level number\n</code></pre>"},{"location":"client/components/NumberPlayers/","title":"NumberPlayers Component","text":"<p>The \"NumberPlayers\" component is used to store the number of players currently involved in a game session. It allows tracking the number of active players at a given moment. This component stores the following information:</p> <ul> <li><code>numberPlayers</code>: An integer representing the number of active players in the game.</li> </ul> <p>This component is useful for managing multiplayer games where the number of players can dynamically change or for displaying information about the number of active players in a game session.</p>"},{"location":"client/components/NumberPlayers/#example-usage","title":"Example Usage","text":"<p>The \"NumberPlayers\" component is used to track the number of active players in a game session:</p> <pre><code>// Creating a NumberPlayers component\nClient::Components::NumberPlayers players;\nplayers.numberPlayers = 2; // There are currently 2 players in the game session\n\n// Using the NumberPlayers component to manage the number of active players\n</code></pre>"},{"location":"client/components/RendererTexture/","title":"RenderTexture Component","text":"<p>The \"RenderTexture\" component is used to store information about the texture to display or draw in a game scene. It contains data about the location, transformation properties, source, destination, and other texture properties. This component stores the following information:</p> <ul> <li> <p><code>path</code>: A string representing the path to the texture to use.</p> </li> <li> <p><code>z</code>: An integer representing the depth of the texture in the scene (for layering).</p> </li> <li> <p><code>source</code>: A rectangle (of type raylib Rectangle) specifying the source area of the texture to draw.</p> </li> <li> <p><code>dest</code>: A rectangle (of type raylib Rectangle) specifying the destination area where the texture will be drawn.</p> </li> <li> <p><code>origin</code>: A vector (of type raylib Vector2) specifying the origin point of the texture (for rotation or pivot).</p> </li> <li> <p><code>rotation</code>: A float representing the rotation angle of the texture.</p> </li> <li> <p><code>useTransformProperties</code>: A boolean indicating whether transformation properties should be used to draw the texture.</p> </li> <li> <p><code>useHitboxProperties</code>: A boolean indicating whether hitbox properties should be used to determine collisions. This component is used to define and manage the appearance and behavior of textures in the game. It allows specifying how a texture is displayed, positioned, and transformed within a scene.</p> </li> </ul>"},{"location":"client/components/RendererTexture/#example-usage","title":"Example Usage","text":"<p>The \"RenderTexture\" component is used to define the properties of a texture in a game scene:</p> <pre><code>// Creating a RenderTexture component\nClient::Components::RenderTexture texture;\ntexture.path = \"path_to_texture.png\";\ntexture.z = 1;\ntexture.source = r::Rectangle{0, 0, 64, 64};\ntexture.dest = r::Rectangle{100, 100, 64, 64};\ntexture.origin = r::Vector2{32, 32};\ntexture.rotation = 45.0f;\ntexture.useTransformProperties = true;\ntexture.useHitboxProperties = true;\n\n// Using the RenderTexture component to display or draw the texture in the scene\n</code></pre>"},{"location":"client/components/SendPacket/","title":"SendPacket Component","text":"<p>The \"SendPacket\" component is used to store data packets to be sent over the network in the game. It contains a list of packets to be sent. This component is primarily used to manage network communication in the game by storing data packets to transmit.</p> <p>This component includes the following information:</p> <ul> <li><code>packets</code>: A vector (dynamic array) of network packets (of type <code>Network::Packet</code>) to be sent. Each packet can contain specific data to be sent to other clients or servers.</li> </ul> <p>This component is essential for network communication in the game, allowing the storage and management of data to be sent to other players or servers. It is used to send information, commands, or updates over the network.</p>"},{"location":"client/components/SendPacket/#example-usage","title":"Example Usage","text":"<p>The \"SendPacket\" component is used to store data packets to be sent over the network:</p> <pre><code>// Creating a SendPacket component\nClient::Components::SendPacket sendPacket;\n\n// Creating network packets and adding them to the packet list\nNetwork::Packet packet1;\npacket1 &lt;&lt; \"Data for packet 1\";\nsendPacket.packets.push_back(packet1);\n\nNetwork::Packet packet2;\npacket2 &lt;&lt; 42; // Example data (integer)\nsendPacket.packets.push_back(packet2);\n\n// Sending packets over the network\n// ...\n\n// Using the SendPacket component to manage the packets to be sent\n</code></pre>"},{"location":"client/components/SoundComponent/","title":"SoundComponent Component","text":"<p>The \"SoundComponent\" component is used to manage the playback of audio files (sounds) in the game. It allows specifying an audio file to play, controlling playback, looping, and volume of the sound. This component is primarily used for adding sound effects or music to the game.</p> <p>This component includes the following information:</p> <ul> <li> <p><code>path</code>: A string representing the path of the audio file to be played. This can be an audio file in WAV, MP3, or other formats.</p> </li> <li> <p><code>play</code>: A boolean indicator specifying whether the sound should be played (true) or not (false).</p> </li> <li> <p><code>loop</code>: A boolean indicator specifying whether the sound should be played in a loop (true) or not (false).</p> </li> <li> <p><code>stop</code>: A boolean indicator specifying whether the sound should be stopped (true) or not (false).</p> </li> <li> <p><code>volume</code>: A floating-point number representing the volume of the sound (from 0 to 100, with 100 being the maximum volume). This component allows for controlling the playback of audio files in the game by specifying the file to play, whether it should loop, its volume, and whether it should be stopped. It is used to add sound effects and music to the game, enhancing the players' audio experience.</p> </li> </ul>"},{"location":"client/components/SoundComponent/#example-usage","title":"Example Usage","text":"<p>The \"SoundComponent\" component is used to manage the playback of audio files in the game:</p> <pre><code>// Creating a SoundComponent component\nClient::Components::SoundComponent sound;\n\n// Specifying the path of the audio file\nsound.path = \"audio/mysound.wav\";\n\n// Playing the sound\nsound.play = true;\n\n// Adjusting the volume\nsound.volume = 50; // Setting the volume to 50%\n\n// Looping the sound\nsound.loop = true;\n\n// Stopping the playback\nsound.stop = false;\n\n// Using the SoundComponent component to manage audio playback\n</code></pre>"},{"location":"client/scene/gameScene/","title":"Level","text":""},{"location":"client/scene/gameScene/#mob-waves","title":"Mob Waves","text":"<p>Mob waves represent waves of enemies that appear at specific moments in the game. They are implemented using the <code>Client::Components::EnemyWaveSpawn</code> component and the  <code>Client::Components::EnemyWaveSpawnSystem</code> system.</p> <p>Exemple de code :</p> <pre><code>// Creating a mob wave\nAddComponent&lt;Client::Components::EnemyWaveSpawn&gt;(\nCreateEntity(\"enemyWaveSpawn\"), {8, 22, 800, {ENEMY_TYPE_1}});\n</code></pre>"},{"location":"client/scene/gameScene/#power-up","title":"Power-up","text":"<p>Power-ups are objects that players can collect to gain advantages. Specific code for power-ups is not provided, but they can be set up in a similar manner to other game elements.</p>"},{"location":"client/scene/gameScene/#drop-item","title":"Drop Item","text":"<p>Drop items are objects that enemies leave behind when destroyed by the player. Specific code for managing drop items is not provided, but they would be handled by components and systems similar to power-ups.</p>"},{"location":"client/scene/gameScene/#boss","title":"Boss","text":"<p>Bosses are powerful enemies that are typically larger and more challenging to defeat. They are implemented using the <code>Client::Components::EnemyWaveSpawn</code> component and the  <code>Client::Components::EnemyWaveSpawnSystem</code> system.</p> <p>Example code:</p> <pre><code>// Creating a boss\nAddComponent&lt;Client::Components::EnemyWaveSpawn&gt;(\nCreateEntity(\"enemyWaveSpawn\"), {60, 1, 1500, {BOSS_TYPE_1}});\n</code></pre>"},{"location":"client/scene/gameScene/#obstacle","title":"Obstacle","text":"<p>Obstacles are environmental elements that can block the movement of players or enemies. Specific code for obstacles is not provided, but they would be managed similarly to other game entities.</p>"},{"location":"client/scene/lobbyScene/","title":"Lobby","text":""},{"location":"client/scene/lobbyScene/#boutons","title":"Boutons","text":"<p>Similar to the \"Home\" scene, the \"Lobby\" scene also features interactive buttons. These buttons are created using the CreateButton method, and each button has components such as Client::Components::IsHover and Client::Components::IsClicked to handle mouse interactions.</p> <p>Example code for creating a button in the \"Lobby\" scene:</p> <pre><code>CreateButton(\"multiplayer\", \"./assets/menu/btn-start\", r::GetScreenHeight() / 2);\n</code></pre>"},{"location":"client/scene/lobbyScene/#mouse-position-tracking","title":"Mouse Position Tracking","text":"<p>Mouse position tracking is managed by the <code>TrackMousePositionSystem</code>.  It updates the mouse entity's position based on the actual mouse position.</p> <p>Example code for mouse position tracking:</p> <pre><code>core.AddSystem(\"track-mouse-position\", Client::Scenes::Home::TrackMousePositionSystem);\n</code></pre>"},{"location":"client/scene/lobbyScene/#displaying-the-number-of-players","title":"Displaying the Number of Players","text":"<p>Here's your description translated into Markdown:</p> <p>Lobby Operation Introduction The \"Lobby\" scene is an important part of the game and contains several essential game elements. This documentation will explain how these elements work in the code.</p> <p>Buttons Similar to the \"Home\" scene, the \"Lobby\" scene also features interactive buttons. These buttons are created using the CreateButton method, and each button has components such as Client::Components::IsHover and Client::Components::IsClicked to handle mouse interactions.</p> <p>Example code for creating a button in the \"Lobby\" scene:</p> <p>cpp Copy code CreateButton(\"multiplayer\", \"./assets/menu/btn-start\", r::GetScreenHeight() / 2); Mouse Position Tracking Mouse position tracking is managed by the TrackMousePositionSystem. It updates the mouse entity's position based on the actual mouse position.</p> <p>Example code for mouse position tracking:</p> <p>cpp Copy code core.AddSystem(\"track-mouse-position\", Client::Scenes::Home::TrackMousePositionSystem); Displaying the Number of Players The \"Lobby\" scene displays the number of connected players. This is managed using the <code>renderPlayers</code>. system. The number of players is stored in a  <code>Client::Components::NumberPlayers</code>component.</p> <p>Example code for displaying the number of players:</p> <pre><code>void Client::Scenes::Lobby::renderPlayers(RNGine::Core &amp;core) {\n  if (core.GetActualSceneName() != \"lobby\")\n    return;\n  auto &amp;scene = core.GetActualScene();\n  auto &amp;numberPlayers =\n      scene.GetComponents&lt;Client::Components::NumberPlayers&gt;()[scene.GetEntity(\n          \"numberPLayers\")];\n  if (!numberPlayers.has_value())\n    return;\n  std::string toPrint;\n  if (numberPlayers-&gt;numberPlayers == 0) {\n    toPrint = \"Connecting...\";\n  } else {\n    toPrint = \"Players: \" + std::to_string(numberPlayers-&gt;numberPlayers);\n  }\n  r::DrawText(toPrint.c_str(), r::GetScreenWidth() - 250, r::GetScreenHeight() - 50, 40,\n           r::LIGHTGRAY);\n}\n</code></pre>"},{"location":"client/scene/menuScene/","title":"Menus","text":""},{"location":"client/scene/menuScene/#boutons","title":"Boutons","text":"<p>Buttons are interactive elements that allow players to navigate the main menu. They are created using the CreateButton method. Each button has components such as Client::Components::IsHover and Client::Components::IsClicked to handle mouse interactions.</p> <p>Example code for creating a button:</p> <pre><code>CreateButton(\"solo\", \"./assets/menu/btn-solo\", 0);\n</code></pre>"},{"location":"client/scene/menuScene/#mouse-position-tracking","title":"Mouse Position Tracking","text":"<p>Mouse position tracking is managed by the TrackMousePositionSystem system. It updates the mouse entity's position based on the actual mouse position.</p> <p>Example code for mouse position tracking:</p> <pre><code>core.AddSystem(\"track-mouse-position\", Client::Scenes::Home::TrackMousePositionSystem);\n</code></pre>"},{"location":"client/scene/menuScene/#background","title":"Background","text":"<p>The scene's background consists of entities like \"background1,\" \"background2,\" \"redmoon,\" and \"greenmoon.\" These entities are created with background textures and are animated to create a parallax effect.</p> <p>Example code for creating a background:</p> <pre><code>CreateEntity(\"background1\");\nscene.AddComponent&lt;Client::Components::RenderTexture&gt;(\n    background1,\n    {\"./assets/levels/space/space_background.png\", -3, {0, 0, 514, 360}});\nscene.AddComponent&lt;RNGine::Components::Transform&gt;(background1,\n    {0, 0, 0, 3.73, 3});\nscene.AddComponent&lt;Client::Components::Parallax&gt;(background1, {{-1920, 1920}});\nscene.AddComponent(background1, RNGine::Addons::Velocity({-100, 0}));\n</code></pre>"},{"location":"client/systems/CheckDamage/","title":"CheckDamage","text":"<p>The \"CheckDamage\" system is responsible for managing damage-related collisions in the game. It checks for collisions between attackable entities (objects or enemies) and entities that inflict damage (such as projectiles). When a collision is detected, the system handles damage, points, and other interactions related to collisions.</p> <p>This system checks for collisions between the \"Collider\" components (RNGine::Addons::Collider), \"Attackable\" components (RNGine::Components::Attackable), and \"MakeDamage\" components (RNGine::Components::MakeDamage) in the scene. It takes into account ally values, health, damage, and points to manage interactions.</p>"},{"location":"client/systems/CheckDamage/#features","title":"Features","text":"<p>The \"CheckDamage\" system performs the following actions: - Checks for collisions between attackable entities and entities that inflict damage. - Manages inflicted damage based on detected collisions. - Updates the health of attackable entities. - Manages points (scores) based on inflicted damage and destroyed entities. - Removes entities that are no longer alive.</p>"},{"location":"client/systems/CheckDamage/#example-usage","title":"Example Usage","text":"<p>The \"CheckDamage\" system is used to manage collisions and damage in the game:</p> <pre><code>// Using the CheckDamage system\nClient::Systems::CheckCollisionsDamage(core);\n</code></pre>"},{"location":"client/systems/CheckHealth/","title":"CheckHealth","text":"<p>The \"CheckHealth\" system is responsible for managing the health of entities in the game. It checks the health of attackable entities (objects or enemies) and takes actions in case of zero or lower health. It manages entity removal, generates loot items, and considers win or loss conditions.</p> <p>This system checks the health of \"Attackable\" components (RNGine::Components::Attackable) and takes actions based on the current health. It generates loot items, triggers explosion animations when entities are destroyed, manages transitions to win or loss screens based on game conditions, and removes destroyed entities.</p>"},{"location":"client/systems/CheckHealth/#features","title":"Features","text":"<p>The \"CheckHealth\" system performs the following actions: - Checks the health of attackable entities. - Manages the generation of loot items based on zero or lower health. - Triggers explosion animations when entities are destroyed. - Manages transitions to win or loss screens based on game conditions. - Removes entities that have no health left.</p>"},{"location":"client/systems/CheckHealth/#example-usage","title":"Example Usage","text":"<p>The \"CheckHealth\" system is used to manage health and health-related interactions in the game:</p> <pre><code>// Using the CheckHealth system\nClient::Systems::CheckHealth(core);\n</code></pre>"},{"location":"client/systems/CheckInvulnerability/","title":"CheckInvulnerability","text":"<p>The \"CheckInvulnerability\" system is responsible for managing the invulnerability of attackable entities in the game. It controls the duration of invulnerability for entities after taking damage, thus controlling the frequency of possible attacks.</p> <p>This system checks the time elapsed since the last attack received by attackable entities and restores their ability to be attacked once the invulnerability time has passed.</p>"},{"location":"client/systems/CheckInvulnerability/#features","title":"Features","text":"<p>The \"CheckInvulnerability\" system performs the following actions: - Checks the invulnerability time of attackable entities. - Restores the ability to be attacked after the invulnerability time has passed.</p>"},{"location":"client/systems/CheckInvulnerability/#example-usage","title":"Example Usage","text":"<p>The \"CheckInvulnerability\" system is used to manage the invulnerability time of attackable entities in the game:</p> <pre><code>// Using the CheckInvulnerability system\nClient::Systems::CheckInvulnerability(core);\n</code></pre>"},{"location":"client/systems/CheckSolidCollider/","title":"CheckSolidCollider","text":"<p>The \"CheckSolidCollider\" system is responsible for managing collisions between solid entities in the game. It detects and handles collisions between solid entities, applying appropriate responses based on the types of collisions.</p> <p>This system is essential for the physics of the game, allowing solid entities to interact correctly with each other. It supports actions such as reflection, entity removal, or applying pushing forces.</p>"},{"location":"client/systems/CheckSolidCollider/#features","title":"Features","text":"<p>The \"CheckSolidCollider\" system performs the following actions: - Detects collisions between solid entities. - Manages the response to collisions by applying pushing forces or causing entities to explode. - Contributes to the physics of the game by allowing solid entities to interact.</p>"},{"location":"client/systems/CheckSolidCollider/#example-usage","title":"Example Usage","text":"<p>The \"CheckSolidCollider\" system is used to manage collisions between solid entities in the game:</p> <pre><code>// Using the CheckSolidCollider system\nClient::Systems::CheckSolidCollider(core);\n</code></pre>"},{"location":"engine/core/","title":"Class Core","text":""},{"location":"engine/core/#constructor","title":"Constructor","text":"<p>The <code>Core</code> class has a constructor that initializes the engine's basic attributes:</p> <pre><code>Core();\n\n</code></pre> <ul> <li> <p><code>currentTime</code>: The current time of the engine.</p> </li> <li> <p><code>nextUpdate</code>: The expected time for the next game update.</p> </li> <li> <p><code>lastUpdate</code>: The time of the last game update.</p> </li> <li> <p><code>deltaTime</code>: The time elapsed since the last update.</p> </li> <li> <p><code>targetFPS</code>: The game's target frame rate (default is 60 frames per second).</p> </li> </ul>"},{"location":"engine/core/#update-method","title":"\"Update\" Method","text":"<p>The Update method is responsible for updating the engine. It calculates the time elapsed since the last update and determines if the engine should be updated at the next step:</p> <pre><code>void update();\n</code></pre> <ul> <li> <p><code>currentTime</code>: Updates the current time.</p> </li> <li> <p><code>nextUpdate</code>: CCalculates when the next update should occur.</p> </li> <li> <p><code>deltaTime</code>: Calculates the time elapsed since the last update.</p> </li> <li> <p><code>RunSystems</code>: Calls the RunSystems function to execute registered systems.</p> </li> </ul> <p>The <code>update</code> method allows you to obtain the current time as a Time data type:</p>"},{"location":"engine/core/#methode-getnow","title":"M\u00e9thode \"GetNow\"","text":"<p>The <code>GetNow</code> method returns true if the engine should be updated at the next step; otherwise, it returns \"false.\"</p> <pre><code>Time getNow();\n</code></pre> <ul> <li>It uses the <code>&lt;chrono&gt;</code> library to obtain the current time in seconds.</li> </ul>"},{"location":"engine/core/#systems-management","title":"Systems Management","text":"<p>The <code>Core</code> class enables you to add, remove, and run systems. A system is a function that</p> <ul> <li>AddSystem :  Allows you to add a system to the engine by providing a unique name and an associated function.</li> <li>RemoveSystem: Allows you to remove a system from the engine using its name.</li> <li>RunSystems: Executes all registered systems in the engine.</li> </ul>"},{"location":"engine/core/#scenes-management","title":"Scenes Management","text":"<p>The R-type engine manages multiple game scenes. The Core class allows you to add, remove, and set the current scene.</p> <ul> <li> <p><code>AddScene</code>: Enables you to add a scene to the engine by providing a unique name and an instance of the Scene class.</p> </li> <li> <p><code>RemoveScene</code>: Allows you to remove a scene from the engine using its name.</p> </li> <li> <p><code>SetActualScene</code>: Sets the current scene to be displayed and updated.</p> </li> </ul>"},{"location":"engine/core/#accessing-scenes","title":"Accessing Scenes","text":"<p>The Core class allows you to access scenes by their name:</p> <ul> <li>GetScene:  Allows you to obtain a reference to a scene by its name.</li> <li>GetActualScene: Allows you to obtain a reference to the currently active scene.</li> </ul>"},{"location":"engine/core/#accessing-the-name-of-the-current-scene","title":"Accessing the Name of the Current Scene","text":"<p>The <code>GetActualSceneName</code>  method allows you to obtain the name of the current scene.</p> <p>The <code>Core</code> class is an essential component of the R-type engine, ensuring the management of time, systems, and scenes, making it a central element of the game.</p>"},{"location":"engine/sparseArray/","title":"Class SparseArray","text":"<p>The <code>SparseArray</code> class is a data structure designed to store an array of optional data. It is used in the R-type game engine to efficiently manage components.</p>"},{"location":"engine/sparseArray/#usage","title":"Usage","text":"<p>The <code>SparseArray</code> class is a generic container designed to store data of type <code>Component</code>. It provides a set of methods to access, insert, remove, and search for elements in the array.</p>"},{"location":"engine/sparseArray/#constructors","title":"Constructors","text":"<p>The <code>SparseArray</code> class has a default constructor, a copy constructor, a move constructor, and a destructor.</p>"},{"location":"engine/sparseArray/#operators","title":"Operators","text":"<ul> <li><code>operator[]</code>: Allows access to an element in the array by its index. If the index is greater than the current size of the array, an empty element of type <code>Component</code> is returned.</li> </ul>"},{"location":"engine/sparseArray/#methods","title":"Methods","text":"<ul> <li><code>begin</code>, <code>end</code>, <code>cbegin</code>, <code>cend</code>: Allow traversing the array using iterators.</li> <li><code>size</code>: Returns the current size of the array.</li> <li><code>insert_at</code>: Inserts a <code>Component</code> element at a given position in the array.</li> <li><code>erase</code>: Removes an element at a given position in the array.</li> <li><code>get_index</code>: Returns the index of an element in the array.</li> </ul>"},{"location":"engine/sparseArray/#example-usage","title":"Example Usage","text":"<pre><code>// Creating a SparseArray of components\nRNGine::SparseArray&lt;Component&gt; sparseArray;\n\n// Inserting a component at index 3\nComponent comp;\nsparseArray.insert_at(3, comp);\n\n// Accessing a component at index 1\nComponent retrievedComp = *sparseArray[1];\n\n</code></pre>"},{"location":"engine/addons/acceleration/","title":"Addon \"Acceleration\"","text":"<p>\"The \"Acceleration\" addon is used to set the acceleration speed in the x and y directions for game entities. This addon is helpful for creating smooth movements by changing the entities' speed over time.\"</p>"},{"location":"engine/addons/acceleration/#example-of-use","title":"Example of use","text":"<pre><code>RNGine::Addons::Acceleration acceleration;\n\nacceleration.x = 0.5f;  // Acc\u00e9l\u00e9ration horizontale\nacceleration.y = 0.2f;  // Acc\u00e9l\u00e9ration verticale\n\n// Appliquer l'acc\u00e9l\u00e9ration \u00e0 une entit\u00e9\nentity.addAddon(acceleration);\n</code></pre>"},{"location":"engine/addons/collider/","title":"Addon \"Collider\"","text":"<p>The \"Collider\" addon is used to handle collision detection between game entities. It keeps a list of colliding entities and provides information about the collisions, like the involved entities, hitboxes, and related transformations.</p>"},{"location":"engine/addons/collider/#exemple-dutilisation","title":"Exemple d'utilisation","text":"<pre><code>RNGine::Addons::Collider collider;\n\n// Define the entity's collision box (hitbox)\nRNGine::Components::Hitbox hitbox;\nhitbox.width = 32;\nhitbox.height = 32;\n\n// Add the collision box to the entity\nentity.addComponent(hitbox);\n\n// Apply the \"Collider\" addon to the entity\nentity.addAddon(collider);\n\n</code></pre>"},{"location":"engine/addons/limits/","title":"Addon Limits","text":"<p>The \"Limits\" addon is used to set boundaries for entities' movement. It specifies the minimum and maximum values for position, speed, and acceleration in the horizontal (x) and vertical (y) directions. This helps restrict where entities can move within specific areas of the game.</p>"},{"location":"engine/addons/limits/#example-of-use","title":"Example of use","text":"<pre><code>RNGine::Addons::Limits limits;\n\nlimits.minX = 0.0f;    // Minimum position in the horizontal (x) direction\nlimits.maxX = 800.0f;  // Maximum position in the horizontal (x) direction\nlimits.minY = 0.0f;    // Minimum position in the vertical (y) direction\nlimits.maxY = 600.0f;  // Maximum position in the vertical (y) direction\n\n// Apply the limits to an entity\nentity.addAddon(limits);\n</code></pre>"},{"location":"engine/addons/velocity/","title":"Addon Velocity","text":"<p>The \"Velocity\" addon is used to control the speed of entities in both the horizontal (x) and vertical (y) directions. It allows you to set the movement speed of entities.</p>"},{"location":"engine/addons/velocity/#example-of-use","title":"Example of use","text":"<pre><code>RNGine::Addons::Velocity velocity;\n\nvelocity.x = 2.0f;  // Horizontal speed\nvelocity.y = 1.5f;  // Vertical speed\n\n// Apply the velocity to an entity\nentity.addAddon(velocity);\n</code></pre>"},{"location":"engine/components/hitbox/","title":"Composant Hitbox","text":"<p>The \"Hitbox\" component is used to define a rectangular collision area associated with a game entity. It stores the following information:</p> <ul> <li> <p><code>width</code>: The width of the hitbox.</p> </li> <li> <p><code>height</code>: The height of the hitbox.</p> </li> <li> <p><code>originX</code>: The x-position of the origin point of the hitbox.</p> </li> <li> <p><code>originY</code>: The y-position of the origin point of the hitbox.</p> </li> </ul> <p>The \"Hitbox\" component is crucial for detecting collisions between entities in the game. By using the dimensions and origin point of the collision box, it is possible to efficiently calculate collisions.</p>"},{"location":"engine/components/hitbox/#example-of-use","title":"Example of use","text":"<pre><code>RNGine::Components::Hitbox hitbox;\nhitbox.width = 32;\nhitbox.height = 32;\nhitbox.originX = 16;\nhitbox.originY = 16;\n</code></pre>"},{"location":"engine/components/transform/","title":"Composant \"Transform\"","text":"<p>The \"Transform\" component is used to define the spatial transformation of a game entity. It stores the following information:</p> <ul> <li> <p><code>x</code>: The position x.</p> </li> <li> <p><code>y</code>: The position y.</p> </li> <li> <p><code>rotation</code>: The rotation of the entity (in degrees).</p> </li> <li> <p><code>scaleX</code>: The scale in the x-axis of the entity.</p> </li> <li> <p><code>scaleY</code>:  The scale in the y-axis of the entity.</p> </li> </ul> <p>The \"Transform\" component allows you to position, orient, and resize an entity within the game world.</p>"},{"location":"engine/components/transform/#exemple-dutilisation","title":"Exemple d'utilisation","text":"<pre><code>RNGine::Components::Transform transform;\ntransform.x = 100;\ntransform.y = 200;\ntransform.rotation = 45; // 45-degree rotation\ntransform.scaleX = 1.5; // Scale in the x-axis of 1.5\ntransform.scaleY = 1.5; // Scale in the y-axis of 1.5\n\n// Using the Transform component to position, orient, and resize an entity.\n</code></pre>"},{"location":"library/component/","title":"Components","text":"<p>In our R-Type game, components are essential building blocks that define the characteristics and behaviors of entities. Each entity is composed of various components, which collectively determine its functionality within the game. Understanding how components are used and managed is crucial for developers working on our project.</p>"},{"location":"library/component/#attackable","title":"Attackable","text":"<p>The Attackable component defines attributes related to an entity's vulnerability to damage. It includes properties like hit points, defensive capabilities, and interactions with offensive components.</p>"},{"location":"library/component/#collider","title":"Collider","text":"<p>The Collider component is responsible for managing an entity's collision properties. It defines the collision shape, size, and behaviors, crucial for interactions between entities and the game environment.</p>"},{"location":"library/component/#enemyshoot","title":"EnemyShoot","text":"<p>The EnemyShoot component is used to specify attributes related to an entity's shooting behavior. It defines the type of projectiles, firing rates, and targeting characteristics for entities that can shoot at the player or other entities.</p>"},{"location":"library/component/#makedamage","title":"MakeDamage","text":"<p>The MakeDamage component represents an entity's ability to inflict harm or damage to other entities. It defines the damage output, attack range, and other characteristics necessary for combat.</p>"},{"location":"library/component/#movable","title":"Movable","text":"<p>The Movable component handles an entity's movement capabilities. It specifies the entity's speed, direction, and behaviors related to navigation and mobility within the game.</p>"},{"location":"library/component/#selfdestroy","title":"SelfDestroy","text":"<p>The SelfDestroy component is used to manage an entity's behavior when it needs to self-destruct or be removed from the game. It includes properties related to removal conditions and effects.</p>"},{"location":"library/component/#shoot","title":"Shoot","text":"<p>The Shoot component defines an entity's ability to fire projectiles or attacks. It includes characteristics such as the type of ammunition, firing patterns, and targeting behavior.</p>"},{"location":"library/component/#size","title":"Size","text":"<p>The Size component specifies the dimensions of an entity, such as its width and height. It influences the entity's visual representation and collision detection.</p>"},{"location":"library/component/#sprite","title":"Sprite","text":"<p>The Sprite component is responsible for the visual appearance of an entity. It defines the graphical representation, texture, and appearance of the entity in the game.</p>"},{"location":"library/component/#velocity","title":"Velocity","text":"<p>The Velocity component represents an entity's speed and direction of movement. It controls how an entity moves within the game world.</p>"},{"location":"library/component/#text","title":"Text","text":"<p>The Text component is used to handle textual information related to an entity, such as labels, descriptions, or other text-based attributes associated with the entity.</p>"},{"location":"library/component/#example-of-adding-components-to-an-entity","title":"Example of Adding Components to an Entity:","text":"<pre><code>addComponent(e, RNGine::components::Sprite::createSprite(\"./assets/Player.gif\", false, 33, 17, 2, 2, 2));\naddComponent(e, RNGine::components::Position::createPosition(25, 500));\naddComponent(e, RNGine::components::Size::createSize(3, 3));\naddComponent(e, RNGine::components::Velocity::createVelocity(0, 0));\naddComponent(e, RNGine::components::Collider::createCollider(33 * 3, 17 * 3));\n</code></pre>"},{"location":"library/component/#summary","title":"Summary","text":"<p>Components are fundamental to the architecture of our R-Type game. They define the attributes and behavior of entities, allowing for the creation of complex and dynamic gameplay. Understanding how to add, remove, and utilize components is essential for game development in our project.</p>"},{"location":"library/entity/","title":"Entity Management (Entities)","text":"<p>In our R-Type game, entities play a central role. Entities represent objects in the game world, such as spaceships, enemies, projectiles, and various other interactive elements. Understanding how entities are managed is essential for any developer working on our game.</p>"},{"location":"library/entity/#creating-entities","title":"Creating Entities","text":"<p>Entities are created dynamically during the game. Each entity is associated with a unique identifier and is composed of multiple components that define its characteristics.</p>"},{"location":"library/entity/#example-of-creating-an-entity","title":"Example of Creating an Entity:","text":"<pre><code>createPlayer(createEntity(\"player\")); \naddComponent(e, RNGine::components::Position::createPosition(x, y));\naddComponent(e, RNGine::components::Size::createSize(scaleWidth, scaleHeight));\n</code></pre>"},{"location":"library/entity/#using-entities","title":"Using Entities","text":"<p>Entities are updated and managed by the systems of the ECS architecture. Systems act on entities based on the associated components.</p>"},{"location":"library/entity/#example-of-using-entities","title":"Example of Using Entities:","text":"<pre><code>RNGine::Entity Registry::getEntity(std::string const &amp;name) {\n    auto it = _entities.find(name);\n    if (it != _entities.end()) {\n        return it-&gt;second;\n    }\n    throw std::runtime_error(\"Entity not found in registry.\");\n}\n</code></pre>"},{"location":"library/entity/#destroying-entities","title":"Destroying Entities","text":"<p>Entities can be destroyed when they are no longer needed. Associated components are removed, freeing up resources.</p>"},{"location":"library/entity/#example-of-destroying-an-entity","title":"Example of Destroying an Entity:","text":"<pre><code>void Registry::removeEntity(RNGine::Entity entity) {\n    for (auto remove : _removes) {\n        remove.second(*this, entity);\n    }\n}\n</code></pre>"},{"location":"library/entity/#interaction-between-entities","title":"Interaction Between Entities","text":"<p>Entities can interact with each other, for example, projectiles may inflict damage on other entities. This interaction is managed by the systems and events within the game.</p>"},{"location":"library/entity/#summary","title":"Summary","text":"<p>The management of entities is a key element of the ECS architecture of our R-Type game. Entities are created dynamically, updated by systems, and potentially destroyed during the game. They form the foundation of the gaming experience and are essential for creating an interactive and dynamic world.</p>"},{"location":"library/game_loop/","title":"Game Loop","text":"<p>In our R-Type game, the game loop is the heart of the game's execution. It is a fundamental concept in game development and is responsible for ensuring that the game runs smoothly and continuously.</p>"},{"location":"library/game_loop/#overview","title":"Overview","text":"<p>The game loop is a repetitive cycle that includes the following key steps:</p> <ol> <li> <p>Input Processing: During this phase, the game checks for player input. It includes actions like moving the player's ship, firing projectiles, and responding to other user interactions.</p> </li> <li> <p>Update: In the update phase, the game logic is executed. This involves processing the movement, behavior, and interactions of game entities such as player ships, enemies, and projectiles. This step also manages the progression of the game state, including scoring, level advancement, and enemy behavior.</p> </li> <li> <p>Collision Detection: To determine if any entities in the game have collided, the collision detection phase is crucial. Collisions can result in damage, destruction, or other game events.</p> </li> <li> <p>Render: The render phase focuses on displaying the game's visual elements. It draws the current state of the game world, including the positions and animations of entities, backgrounds, and user interface elements.</p> </li> </ol>"},{"location":"library/game_loop/#frame-rate","title":"Frame Rate","text":"<p>The game loop runs at a constant frame rate, ensuring that the game's logic and rendering are consistent and predictable. A typical frame rate for modern games is 60 frames per second (FPS), although this can vary depending on the game's requirements and platform.</p>"},{"location":"library/game_loop/#synchronization","title":"Synchronization","text":"<p>Synchronization mechanisms may be employed to ensure that the game loop runs consistently, especially on different hardware or platforms. This can prevent issues like screen tearing and ensure that the game operates as expected.</p>"},{"location":"library/game_loop/#game-state","title":"Game State","text":"<p>The game loop is responsible for managing the game state, including player scores, level progression, and more. It determines when the game starts, pauses, resumes, and ends based on various conditions and player interactions.</p> <p>The game loop is a critical component in delivering an engaging and interactive gaming experience. It's essential to maintain a stable frame rate and responsiveness, ensuring that players can immerse themselves in the R-Type universe.</p> <p>Feel free to use this content in your documentation.</p>"},{"location":"library/scenes/","title":"Gestion des Sc\u00e8nes","text":"<p>Dans R-Type, la gestion des sc\u00e8nes vous permet d'organiser et de contr\u00f4ler les diff\u00e9rentes parties du jeu, comme le menu principal, les niveaux et les \u00e9crans de fin.</p>"},{"location":"library/scenes/#vue-densemble","title":"Vue d'ensemble","text":"<p>La classe <code>Scene</code> de notre moteur de jeu offre les fonctionnalit\u00e9s suivantes :</p> <ul> <li>Cr\u00e9ation d'objets (entit\u00e9s) pour le jeu.</li> <li>Ajout de paquets de syst\u00e8mes pour g\u00e9rer le gameplay.</li> <li>Chargement et d\u00e9chargement de sc\u00e8nes pour changer l'\u00e9tat du jeu.</li> </ul>"},{"location":"library/scenes/#comment-ca-fonctionne","title":"Comment \u00e7a Fonctionne","text":"<ul> <li> <p>Cr\u00e9ez des entit\u00e9s pour repr\u00e9senter des \u00e9l\u00e9ments du jeu tels que des vaisseaux et des ennemis en utilisant <code>createEntity</code>.</p> </li> <li> <p>Acc\u00e9dez \u00e0 des entit\u00e9s sp\u00e9cifiques par leur nom ou identifiant avec <code>getEntity</code>.</p> </li> <li> <p>Ajoutez des paquets de syst\u00e8mes pour g\u00e9rer divers aspects du jeu, tels que la physique et les entr\u00e9es.</p> </li> <li> <p>Chargez ou d\u00e9chargez des sc\u00e8nes pour basculer entre diff\u00e9rentes parties du jeu.</p> </li> <li> <p>Mettez \u00e0 jour la sc\u00e8ne pour faire progresser le gameplay en r\u00e9agissant aux actions des joueurs.</p> </li> <li> <p>Chaque sc\u00e8ne peut \u00eatre identifi\u00e9e de mani\u00e8re unique.</p> </li> </ul>"},{"location":"library/scenes/#exemple-dutilisation","title":"Exemple d'Utilisation","text":"<p>Voici un exemple de la mani\u00e8re dont vous pourriez utiliser la classe <code>Scene</code> de notre moteur de jeu pour g\u00e9rer les sc\u00e8nes :</p> <pre><code>RNGine::Entity playerEntity = currentScene.createEntity(\"player\");\n\nRNGine::Registry::SystemBundle physicsBundle = {PhysicsSystem};\ncurrentScene.addBundle(physicsBundle);\n\ncurrentScene.load();\n\nstd::map&lt;enum RNGine::Key, bool&gt; keybinds = getInput();\ncurrentScene.update(keybinds);\n</code></pre>"},{"location":"library/system/","title":"Game Systems","text":""},{"location":"library/system/#collision-check-system-shootcollisionsystem","title":"Collision Check System (ShootCollisionSystem)","text":"<p>The Collision Check System manages collision detection between game entities. It checks if entities collide, which can trigger events like damage or destruction.</p>"},{"location":"library/system/#shoot-system-shootsystem","title":"Shoot System (ShootSystem)","text":"<p>The Shoot System controls the creation and behavior of projectiles fired by entities. It allows entities to fire projectiles based on player or AI input.</p>"},{"location":"library/system/#enemy-shoot-system-enemyshoot","title":"Enemy Shoot System (EnemyShoot)","text":"<p>The Enemy Shoot System governs the behavior of enemies regarding shooting. It defines how enemies shoot projectiles, their speed, and fire rate.</p>"},{"location":"library/system/#health-check-system-checkhealth","title":"Health Check System (CheckHealth)","text":"<p>The Health Check System monitors entity health and performs checks to determine if they have been destroyed. It can award points to the player based on destroyed entities.</p>"},{"location":"library/system/#score-update-system-updatescore","title":"Score Update System (UpdateScore)","text":"<p>The Score Update System keeps the game scores updated based on in-game events. It can update scores in real-time.</p>"},{"location":"library/system/#velocity-management-system-velocitysystem","title":"Velocity Management System (velocitySystem)","text":"<p>The Velocity Management System handles the speed of entities by updating their positions based on their velocity.</p>"},{"location":"library/system/#movement-management-system-movablesystem","title":"Movement Management System (MovableSystem)","text":"<p>The Movement Management System controls entity movement based on player or AI inputs.</p>"},{"location":"library/system/#self-destruct-system-selfdestroy","title":"Self-Destruct System (SelfDestroy)","text":"<p>The Self-Destruct System manages entities that need to self-destruct when they leave predefined areas.</p> <p>These systems work in harmony to create an immersive gaming experience in our R-Type game. Each has a specific role to play, contributing to the depth of gameplay.</p> <p>Feel free to copy and paste this content into your documentation.</p>"},{"location":"library/system/#example-of-adding-systems","title":"Example of Adding Systems:","text":"<pre><code>  addBundle(Rtype::physicsSystems);\n  addBundle(Rtype::shootsSystems);\n  addBundle(Rtype::engineSystems);\n</code></pre>"},{"location":"server/rfc/","title":"RFC DOCUMENTATION :","text":"<p>Version Number: 1</p> <p>Publication Date: October 2023</p> <p>Authors: Alexandre Frede, L\u00e9andre Sentenac, K\u00e9ziah Imer, Adil Nouiri, Thomas Papaix</p>"},{"location":"server/rfc/#introduction","title":"Introduction :","text":"<p>This document establishes a binary communication protocol for the R-Type game using the User Datagram Protocol (UDP). The protocol facilitates the exchange of commands and data between clients and the proxy server. Each message is encapsulated in a defined structure, including elements such as the command to be executed, a status code, and associated content.</p>"},{"location":"server/rfc/#message-structure","title":"Message Structure :","text":"<p>The messages exchanged between clients and the server follow the defined binary structure below:</p> <pre><code>enum Command {\n    LOGIN,\n    START,\n    MOVE,\n    SHOOT\n};\n\nenum Code {\n    SUCCESS,\n    ERROR,\n    NONE\n};\n\ntypedef struct Data_t {\n    enum Command command;\n    enum Code code;\n    char content[1024];\n} Data;\n</code></pre> <ul> <li><code>command</code>: Indicates the action to be performed (LOGIN, START, MOVE, SHOOT, or NOTHING).</li> <li><code>code</code>: Represents the status of the operation (SUCCESS, ERROR, or NONE).</li> <li><code>content</code>: Contains data associated with the command, such as movement coordinates, shoot details, etc.</li> </ul>"},{"location":"server/rfc/#exchange-procedure","title":"Exchange Procedure","text":""},{"location":"server/rfc/#client-to-server","title":"Client to Server","text":"<p>When a client wants to send a command to the server, it encapsulates the <code>Data</code> structure into a binary stream and sends it via the appropriate transport protocol.</p>"},{"location":"server/rfc/#server-to-client","title":"Server to Client","text":"<p>The proxy server receives messages from clients, processes them based on the command, and redistributes them to other connected clients, except for the LOGIN message. Clients receive the data, decode the Data structure from the binary stream, and act accordingly.</p>"},{"location":"server/rfc/#error-handling","title":"Error Handling","text":"<p>Communication errors are managed using the <code>code</code> field of the <code>Data</code> structure. In case of an error, the <code>ERROR</code> code is sent back to inform the client of the operation failure, otherwise, the <code>SUCCESS</code> code is sent back. The <code>NONE</code> code is used for the request like a neutral code.</p>"},{"location":"server/rfc/#commands","title":"Commands","text":"<ol> <li>LOGIN</li> <li>Arguments: N/A</li> <li> <p>Description: Identifies the new client, typically used for creating a new spaceship and establishing its presence in the game environment and transitions the game from the menu to a lobby where players gather.</p> </li> <li> <p>START</p> </li> <li>Arguments: N/A</li> <li> <p>Description: Starts the game for all players in the lobby.</p> </li> <li> <p>MOVE</p> </li> <li>Arguments: <code>vx,vy,px,py,id</code> (comma-separated values)</li> <li> <p>Description: Moves the spaceship corresponding to the given <code>id</code>. The arguments represent velocity (<code>vx</code>, <code>vy</code>) and position (<code>px</code>, <code>py</code>) coordinates, along with the unique identifier (<code>id</code>) of the spaceship.</p> </li> <li> <p>SHOOT</p> </li> <li>Arguments: <code>id</code></li> <li>Description: Triggers the spaceship corresponding to the given <code>id</code> to shoot in the game.</li> </ol>"}]}